import{_ as c,r as o,o as p,c as t,a as n,b as s,d as e,e as d}from"./app-3a979dd6.js";const l={},i=d(`<h2 id="_1-js-内存管理" tabindex="-1"><a class="header-anchor" href="#_1-js-内存管理" aria-hidden="true">#</a> 1.JS 内存管理</h2><h4 id="_1-1-内存生命周期" tabindex="-1"><a class="header-anchor" href="#_1-1-内存生命周期" aria-hidden="true">#</a> 1.1 内存生命周期</h4><p><code>分配内存</code> =&gt; <code>内存读写</code> =&gt; <code>释放内存</code></p><p>在 JS 语言中，内存分配是由 JS 引擎自动完成的，释放内存也是如此，由 JS 引擎根据垃圾回收机制进行回收，开发者能控制的是内存读写这一环节</p><h4 id="_1-2-两种内存存储类型" tabindex="-1"><a class="header-anchor" href="#_1-2-两种内存存储类型" aria-hidden="true">#</a> 1.2 两种内存存储类型</h4><p><code>基本类型</code>：内存是<code>固定大小</code>的，其值存储在<code>栈（stack）</code>空间中</p><p><code>引用类型</code>：内存是<code>非固定</code>的，其值存储在<code>堆（heap）</code>空间中，指向堆空间中的对象的<code>指针</code>存储在栈空间中</p><p>不多 bb，来看代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// 在栈中给数值分配内存</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&#39;NO x ONE&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 在栈中给字符串分配内存</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在堆中存储新的对象，在栈中存储指向该对象的指针并赋值给obj变量，由此构成引用关系</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment">// 共享同一个指针</span>
obj2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 这里obj2不再保存指针，但是不会影响obj</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ...</span>
<span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#_2-垃圾回收机制" aria-hidden="true">#</a> 2.垃圾回收机制</h2><h4 id="_2-1-核心原理" tabindex="-1"><a class="header-anchor" href="#_2-1-核心原理" aria-hidden="true">#</a> 2.1 核心原理</h4><p><code>GC</code>即 Garbage Collection，垃圾回收机制。JS 引擎定期找出不再用到的内存，然后释放，至于如何实现有不同的策略，常见的有<code>标记清除算法</code>和<code>引用计数算法</code></p><h4 id="_2-2-标记清除算法" tabindex="-1"><a class="header-anchor" href="#_2-2-标记清除算法" aria-hidden="true">#</a> 2.2 标记清除算法</h4><p><code>标记清除</code>（<code>Mark-Sweep</code>），大多数浏览器的 JS 引擎都在采用这种算法，只是在此基础之上又进行各自的优化加工</p><p>该策略分为<code>Mark</code>和<code>Sweep</code>两个阶段，过程如下:</p><p><code>Mark阶段</code></p><ul><li>运行时在内存中所有变量标记 0（垃圾）</li><li>从各个根对象遍历，将被引用的变量标记变为 1（非垃圾）</li></ul><p><code>Sweep阶段</code></p><ul><li>将所有标记 0 的变量内存释放，GC</li></ul><p>来看看代码:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> fn2 <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 开始执行此函数时，将其作用域中a、B以及匿名函数标记为0</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 0</span>
  <span class="token keyword">let</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 由于这里return出去会被其他变量引用，故标记变为1</span>
    <span class="token function">altert</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// 由于这里的闭包，B的标记变为1</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
  <span class="token comment">// 执行函数完毕，销毁作用域，在某个GC回收循环节清理标记为0的变量a，</span>
  <span class="token comment">// B和匿名函数被保留了下来即非垃圾变量</span>
<span class="token punctuation">}</span>

<span class="token comment">// 补充一下：fn和fn2作为window.fn和window.fn2，标记一直为1，</span>
<span class="token comment">// 仅仅当手动设置fn=null和fn2=null才会标记为0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种策略存在<code>内存碎片化</code>缺陷，即释放的内存空间往往是不连续的，如下图所示:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4718761d56714eff9a364b8bb8e5b297~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>这样不利于内存的回收利用,即空闲内存与非空闲内存是相交错的，不利于存储</p><p>故考虑优化在<code>Mark</code>和<code>Sweep</code>阶段之间再补充上整理<code>Compact</code>阶段</p><ul><li>在<code>Mark</code>阶段结束后，将标记 1 的变量内存往一端移动，标记 0 的变量内存往另一端移动</li><li>开启<code>Sweep</code>阶段</li></ul><p>优化后的策略即标记整理清除算法(Mark-Compact-Sweep)，入下图所示:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b432febb62e249a296d3e20de35e3d7c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h4 id="_2-3-引用计数算法" tabindex="-1"><a class="header-anchor" href="#_2-3-引用计数算法" aria-hidden="true">#</a> 2.3 引用计数算法</h4><p>JS 引擎很早之前使用过这种策略回收内存，其核心思想为：将<code>不再被引用的对象（零引用）</code>作为垃圾回收，需要提醒的是，这种策略由于存在很多问题，目前逐渐被<code>弃用</code>了</p><p>过程如下:</p><ul><li>当声明一个引用类型并赋值给变量时，这个值的引用次数初始为 1</li><li>若该值又被赋值给另一个变量，引用次数+1</li><li>若该变量的被其他值覆盖了，引用次数-1</li><li>当这个值引用次数变为 0 时，说明该值不再被引用，垃圾回收器会在运行时清理释放其内存</li></ul><p>代码如下:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 引用次数初始化为1</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token comment">// 引用次数2，即obj被a和b引用</span>
a<span class="token operator">=</span><span class="token keyword">null</span> <span class="token comment">// 引用次数1</span>
b<span class="token operator">=</span><span class="token keyword">null</span> <span class="token comment">// 引用次数0，</span>
<span class="token operator">...</span> <span class="token comment">// GC回收此引用类型在堆空间中所占的内存</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是存在一些问题，例如最常见的是循环引用现象</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// fn引用次数为1，因为window.fn = fn，会在window=null即浏览器关闭时回收</span>
  <span class="token keyword">let</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// A: 1</span>
  <span class="token keyword">let</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// B: 1</span>
  <span class="token constant">A</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token constant">B</span> <span class="token comment">// B: 2</span>
  <span class="token constant">B</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a <span class="token comment">// A: 2</span>
  <span class="token operator">...</span>
  <span class="token comment">// 执行完fn函数，作用域销毁时，A和B引用次数-1，但是还不为0，</span>
  <span class="token comment">// 在某个GC回收循环执行时不会释放其内存，存在了内存泄漏</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 若执行无限多次fn，那么内存将会被占满，程序宕机</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若是采用<code>标记清除</code>策略则会在<code>fn</code>执行完毕后，作用域销毁，将域中的<code>A</code>和<code>B</code>变量标记为 0 以便 GC 回收内存，不会存在这种问题。</p><h2 id="_3-v8-对-gc-的优化" tabindex="-1"><a class="header-anchor" href="#_3-v8-对-gc-的优化" aria-hidden="true">#</a> 3.V8 对 GC 的优化</h2><p>前面提到，现在大部分浏览器 JS 引擎都采用<code>标记清理</code>策略来实现垃圾回收机制，但是又各自基于此策略又进行了不同的优化，这里主要来看 Chrome 的 JS 引擎<code>V8</code>对此进行的优化</p><h4 id="_3-1-分代式回收" tabindex="-1"><a class="header-anchor" href="#_3-1-分代式回收" aria-hidden="true">#</a> 3.1 分代式回收</h4><p><code>标记清理</code>策略在每次垃圾回收前都要检测内存中所有的对象标记是否为 0 来作为是否回收的依据。若一些大、老、存活长的对象（<code>老生代</code>）与小、新、存活时间短的对象（<code>新生代</code>）采用一个频率检查的话将会消耗很大的性能，故要区别对待。所以 V8 采用<code>分代</code>的方式进行垃圾回收，对前者使用<code>老生代GC</code>（清理频率低），后者采用<code>新生代GC</code>（清理频率高）</p><h5 id="_3-1-1-内存存储分代" tabindex="-1"><a class="header-anchor" href="#_3-1-1-内存存储分代" aria-hidden="true">#</a> 3.1.1 内存存储分代</h5><p>由于 V8 的 GC 策略主要是基于分代，故 V8 存储变量的方式也是分代的，将堆空间开辟为新生代和老生代</p><p><code>新生代内存存储</code>：堆空间内存空间小(1~8MB)，对应 GC 算法<code>Scavenge</code>效率高</p><p><code>老生代内存存储</code>：堆空间内存较大，对应 GC 算法<code>Mark-Compact-Sweep</code>效率稍低</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160a6ec31c4147c4b7680eaa5a112f40~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>这种分配是非常合理的，对于频繁回收操作，<code>牺牲空间换取时间</code>；对于低频回收操作，<code>牺牲时间换取空间</code>。此思想可以类比<code>计算机存储分层结构</code>，将需要读取频率高的存储在小容量、高处理的 cache 中，将读取频率低的存储在大容量、低处理的内存中</p><h5 id="_3-1-2-新生代-gc" tabindex="-1"><a class="header-anchor" href="#_3-1-2-新生代-gc" aria-hidden="true">#</a> 3.1.2 新生代 GC</h5><p>对于新生代采用<code>Scavenge</code>算法进行垃圾回收，将新生代存储区一分为二：<code>使用区</code>、<code>空闲区</code></p><p>过程如下：</p><ul><li>程序运行时，作用域中<code>所有变量</code>都会存入<code>使用区</code>，当该区域内存写满之后就会进行一次 GC</li><li>在 GC 开始前，先将使用区里的<code>活动对象</code>移动到<code>空闲区</code>，<code>非活动对象</code>保留，随后进行 GC，清除保留在使用区里的非活动对象</li><li>GC 结束，将<code>空闲区</code>与<code>使用区</code>进行互换</li></ul><p>如下图所示:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9686e99f26854540886b929f427080c7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h5 id="_3-1-3-老生代-gc" tabindex="-1"><a class="header-anchor" href="#_3-1-3-老生代-gc" aria-hidden="true">#</a> 3.1.3 老生代 GC</h5><p>首先，老生代都是从新生代转变来的，但要经过考核，满足以下任意一种条件即可：</p><ul><li>当一个新生代对象经过多次<code>Scavenge GC</code>仍然是存活，那么就判定它是生命周期长的对象（老油条），会将其移动到老生代内存中，作为老生代对象</li><li>当一个变量刚进入使用区时就已经占了<code>25%</code>（天生的老油条），那么为了性能考虑，直接将其移动到老生代内存中</li></ul><p>随后采用前面所说的<code>Mark-Compact-Sweep</code>即标记整理清除策略来进行垃圾回收即可</p><h4 id="_3-2-并行回收" tabindex="-1"><a class="header-anchor" href="#_3-2-并行回收" aria-hidden="true">#</a> 3.2 并行回收</h4><p>V8 主要是采用<code>分代式回收</code>，但是对于老生代使用<code>Mark-Compact-Sweep</code>性能还是有提升空间，故又对老生代垃圾回收机制采用<code>并行回收</code>进行优化</p><p>首先为什么要<code>并行回收</code>呢？这是由于 JS 是<code>单线程</code>的，运行在主线程上，在 GC 回收也是运行在主线程中，这会造成 JS 脚本暂时堵塞，在 GC 回收完毕才会恢复脚本运行，这种现象叫作<code>全停顿（Stop-To-World）</code>，所以为了加快 GC 回收，V8 引擎引入了<code>并行回收</code>，即并行开启多个<code>辅助线程</code>，协同完成 GC 回收工作（人多好干活，社会主义好啊~）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4740ff845812441c91334ee74fc76aa8~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h4 id="_3-3-并发回收" tabindex="-1"><a class="header-anchor" href="#_3-3-并发回收" aria-hidden="true">#</a> 3.3 并发回收</h4><p>采用<code>并行回收</code>还是存在一个问题，那就是它还是多多少少造成 JS 脚本堵塞，并未从根本上解决问题，所以又提出了<code>并发回收</code>机制，如下图所示:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886e2277801e4055b36884bff3760ab5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>GC 回收完全在辅助线程中进行，不占用主线程，丝毫不会导致 JS 脚本挂起，这就是<code>并发</code>的好处 但是要实现很难，因为主线程在执行 <code>JavaScript</code> 时，堆中的对象<code>引用关系随时可能变化</code>，这时辅助线程之前做的一些标记或者正在进行的标记就会改变，所以需要额外实现一些<code>读写锁</code>机制来控制，具体怎么搞又是一个深入的话题</p><h4 id="_3-4-增量标记、惰性清理" tabindex="-1"><a class="header-anchor" href="#_3-4-增量标记、惰性清理" aria-hidden="true">#</a> 3.4 增量标记、惰性清理</h4><p>这也是对<code>并行回收</code>存在的<code>全停顿</code>现象进行的优化，在<code>Mark</code>阶段采用<code>增量标记</code>代替<code>全停顿标记</code>，在<code>Sweep</code>阶段采用<code>惰性清理</code>来代替，尽最大的可能减少<code>全停顿</code>时间，具体怎么搞也是一个深入的话题</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,68),r={href:"https://github.com/yacan8/blog/issues/33",target:"_blank",rel:"noopener noreferrer"},u={href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management",target:"_blank",rel:"noopener noreferrer"},k={href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"};function m(b,v){const a=o("ExternalLinkIcon");return p(),t("div",null,[i,n("p",null,[n("a",r,[s("1.深入理解 Chrome V8 垃圾回收机制"),e(a)])]),n("p",null,[n("a",u,[s("2.内存管理"),e(a)])]),n("p",null,[n("a",k,[s("3.「硬核 JS」你真的了解垃圾回收机制吗"),e(a)])])])}const f=c(l,[["render",m],["__file","JSnacunguanliyulajihuishoujizhi.html.vue"]]);export{f as default};
